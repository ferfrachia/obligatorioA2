    // CAPICOM constants     var CAPICOM_STORE_OPEN_READ_ONLY = 0;    var CAPICOM_CURRENT_USER_STORE = 2;    var CAPICOM_CERTIFICATE_FIND_SHA1_HASH = 0;    var CAPICOM_CERTIFICATE_FIND_SUBJECT_NAME=1;    var CAPICOM_CERTIFICATE_FIND_ISSUER_NAME = 2;    var CAPICOM_CERTIFICATE_FIND_EXTENDED_PROPERTY = 6;    var CAPICOM_CERTIFICATE_FIND_TIME_VALID = 9;    var CAPICOM_CERTIFICATE_FIND_KEY_USAGE = 12;    var CAPICOM_DIGITAL_SIGNATURE_KEY_USAGE = 0x00000080;    var CAPICOM_AUTHENTICATED_ATTRIBUTE_SIGNING_TIME = 0;    var CAPICOM_INFO_SUBJECT_SIMPLE_NAME = 0;    var CAPICOM_ENCODE_BASE64 = 0;    var CAPICOM_E_CANCELLED = -2138568446;    var CERT_KEY_SPEC_PROP_ID = 6;    var CAPICOM_VERIFY_SIGNATURE_ONLY = 0;    var CAPICOM_VERIFY_SIGNATURE_AND_CERTIFICATE = 1;    var CAPICOM_CHECK_NONE=0;    var CAPICOM_CHECK_TRUSTED_ROOT=1;    var CAPICOM_CHECK_TIME_VALIDITY=2;    var CAPICOM_CHECK_SIGNATURE_VALIDITY=4;    var CAPICOM_CHECK_ONLINE_REVOCATION_STATUS=8;    var CAPICOM_CHECK_OFFLINE_REVOCATION_STATUS=16;    var CAPICOM_CHECK_COMPLETE_CHAIN=32;    var txtCertificate;     function IsCAPICOMInstalled()   {	if(typeof(oCAPICOM) == "object")	{		if( (oCAPICOM.object != null) )     		{      			// We found CAPICOM!     			return true;     		}    	}   }     function init()   {	   // Filter the certificates to only those that are good for my purpose	   var FilteredCertificates = FilterCertificates();	  txtCertificate = document.forms[0].pepe;	   // if only one certificate was found then lets show that as the selected certificate	   if (FilteredCertificates.Count == 1)	   {		txtCertificate.value = FilteredCertificates.Item(1).GetInfo(CAPICOM_INFO_SUBJECT_SIMPLE_NAME);		txtCertificate.hash = FilteredCertificates.Item(1).Thumbprint;	   }	   else	   {		txtCertificate.value = "";		txtCertificate.hash = "";	   }	   // clean up		   FilteredCertificates = null;	      }   function FilterCertificates()   {	   // instantiate the CAPICOM objects	   var MyStore = new ActiveXObject("CAPICOM.Store");	   var FilteredCertificates = new ActiveXObject("CAPICOM.Certificates");	   // open the current users personal certificate store	   try	   {	   	MyStore.Open(CAPICOM_CURRENT_USER_STORE, "My", CAPICOM_STORE_OPEN_READ_ONLY);	   }	   catch (e)	   {		if (e.number != CAPICOM_E_CANCELLED)		{	   		alert("An error occurred while opening your personal certificate store, aborting");			return false;		}	   }	   // find all of the certificates that:	   //   * Are good for signing data	   //	* Have PrivateKeys associated with then - Note how this is being done :)	   //   * Are they time valid	   var FilteredCertificates = MyStore.Certificates.Find(CAPICOM_CERTIFICATE_FIND_KEY_USAGE,CAPICOM_DIGITAL_SIGNATURE_KEY_USAGE).Find(CAPICOM_CERTIFICATE_FIND_TIME_VALID).Find(CAPICOM_CERTIFICATE_FIND_EXTENDED_PROPERTY,CERT_KEY_SPEC_PROP_ID);	   return FilteredCertificates;	   // Clean Up	   MyStore = null;	   FilteredCertificates = null;  }  function FindCertificateByHash(szThumbprint)   {	   // instantiate the CAPICOM objects	   var MyStore = new ActiveXObject("CAPICOM.Store");	   // open the current users personal certificate store	   try	   {	   	MyStore.Open(CAPICOM_CURRENT_USER_STORE, "My", CAPICOM_STORE_OPEN_READ_ONLY);	   }	   catch (e)	   {		if (e.number != CAPICOM_E_CANCELLED)		{	   		alert("An error occurred while opening your personal certificate store, aborting");			return false;		}	   }	   // find all of the certificates that have the specified hash	   var FilteredCertificates = MyStore.Certificates.Find(CAPICOM_CERTIFICATE_FIND_SHA1_HASH, szThumbprint);	   return FilteredCertificates.Item(1);	   // Clean Up	   MyStore = null;	   FilteredCertificates = null;  }  function btnSelectCertificate_OnClick()  {	   // retrieve the filtered list of certificates	   var FilteredCertificates = FilterCertificates();	   var chain = new ActiveXObject("CAPICOM.Chain");	   // if only one certificate was found then lets show that as the selected certificate	  // alert ("Nro de certifciados " +FilteredCertificates.Count  );	   if (FilteredCertificates.Count > 0)	   {		try		{			// Pop up the selection UI		    var SelectedCertificate = FilteredCertificates.Select();		    	var cert = SelectedCertificate.Item(1).IsValid();			cert.CheckFlag = CAPICOM_CHECK_TRUSTED_ROOT | CAPICOM_CHECK_TIME_VALIDITY | CAPICOM_CHECK_SIGNATURE_VALIDITY | CAPICOM_CHECK_ONLINE_REVOCATION_STATUS ;			//cert.CheckFlag =  CAPICOM_CHECK_TIME_VALIDITY | CAPICOM_CHECK_ONLINE_REVOCATION_STATUS ;		    var d = new Date();		    //alert (d.valueOf());			cert.VerificationTime="18/09/2003";   			if (cert.Result)   			{   				alert("OK");   			}   			else   			{   				alert("Revocado");   				chain.build (SelectedCertificate.Item(1));   			   				for (var i=1;i<=chain.Certificates.Count;i++){   					alert(chain.Status(i));   				}   			}   			   					    			txtCertificate.value = SelectedCertificate.Item(1).GetInfo(CAPICOM_INFO_SUBJECT_SIMPLE_NAME);			txtCertificate.hash = SelectedCertificate.Item(1).Thumbprint;		}		catch (e)		{			txtCertificate.value = "";			txtCertificate.hash = "";			alert(e.description);		}	   }	   else	   {		alert("You have no valid certificates to select from");	   }	   // Clean-Up	   SelectedCertificate = null;	   FilteredCertificates = null;   }    function btnVerifySig_OnClick(txtPlainText,txtSignature){		// instantiate the CAPICOM objects	var SignedData = new ActiveXObject('CAPICOM.SignedData');	var certificado;	try{				SignedData.Content=txtPlainText;		SignedData.Verify(txtSignature.value, true, CAPICOM_VERIFY_SIGNATURE_AND_CERTIFICATE);				var cert=SignedData.Certificates.Item(1).IsValid();		cert.CheckFlag = CAPICOM_CHECK_TRUSTED_ROOT | CAPICOM_CHECK_TIME_VALIDITY | CAPICOM_CHECK_SIGNATURE_VALIDITY | CAPICOM_CHECK_ONLINE_REVOCATION_STATUS ;			if (!cert.result){		alert("certificado revocado");		}	}	catch (e){		alert(e.description);		return false;	}	alert('Signature Verified');}function firmar (txtPlain, txtNombre){		var Certificate;	//Se obtienen todos los certificados de usuario que se encuentran instalados en la maquina con el nombre recibido por parametro.	var FilteredCertificates = findCertificado(txtNombre);	  	//Si tiene algun certificado	if (FilteredCertificates.Count==0){		alert ("El usuario " + txtNombre + " no tiene su certficado en este PC");		return null;	}	if (FilteredCertificates.Count==1){		Certificate = FilteredCertificates.Item(1);	}	if (FilteredCertificates.Count > 1){		  // Se despliega un dialogbox el que devuelve el certificado seleccionado.		  var SelectedCertificate = FilteredCertificates.Select();		  Certificate = SelectedCertificate.Item(1);	}		  	//Se crea un objeto certificaction Status para poder verificar que el certificado seleccionado no este revocado	//var certStatus = Certificate.IsValid();		  	//Se setean las opciones a revisar	//certStatus.CheckFlag = CAPICOM_CHECK_COMPLETE_CHAIN | CAPICOM_CHECK_TRUSTED_ROOT | CAPICOM_CHECK_TIME_VALIDITY | CAPICOM_CHECK_SIGNATURE_VALIDITY | CAPICOM_CHECK_ONLINE_REVOCATION_STATUS ;		  	//Se setea el tiempo en el cual se quiere comprobar si el certificado esta revocado	var Today = new Date();		  		  	//certStatus.VerificationTime=Today.getVarDate();	try{		//if (certStatus.Result){			//Se crean objetos para firmar el texto   			var SignedData = new ActiveXObject("CAPICOM.SignedData");	   		var Signer = new ActiveXObject("CAPICOM.Signer");	   		var TimeAttribute = new ActiveXObject("CAPICOM.Attribute");	   		//Se setean los propiedades de los objetos para firmar	   		SignedData.Content = txtPlain;	   		Signer.Certificate = Certificate;	   						TimeAttribute.Name = CAPICOM_AUTHENTICATED_ATTRIBUTE_SIGNING_TIME;			TimeAttribute.Value = Today.getVarDate();					   	Signer.AuthenticatedAttributes.Add(TimeAttribute);						var szSignature = SignedData.Sign(Signer, true, CAPICOM_ENCODE_BASE64);	   		return szSignature;	   		//}   		//else{   		//	alert("Certificado Revocado");   		//	return "NO";   		//}   	}	catch (e){		alert(e.description);		alert("No se ingresó la contraseña correcta para acceder al certificado");		return "NO";	} 	  	  }function verficar(txtPlain, txtSignature){		// instantiate the CAPICOM objects	var SignedData = new ActiveXObject('CAPICOM.SignedData');	var certificado;	var usuario;	usuario="NULL";	try{				SignedData.Content=txtPlain;		SignedData.Verify(txtSignature, true, CAPICOM_VERIFY_SIGNATURE_ONLY);		var cert = SignedData.Certificates.Item(1);		usuario=cert.GetInfo(0);		/*		var certStatus=SignedData.Certificates.Item(1).IsValid();		certStatus.CheckFlag = CAPICOM_CHECK_COMPLETE_CHAIN | CAPICOM_CHECK_TRUSTED_ROOT | CAPICOM_CHECK_TIME_VALIDITY | CAPICOM_CHECK_SIGNATURE_VALIDITY | CAPICOM_CHECK_ONLINE_REVOCATION_STATUS ;			cert.IsValid().CheckFlag = CAPICOM_CHECK_COMPLETE_CHAIN | CAPICOM_CHECK_TRUSTED_ROOT | CAPICOM_CHECK_TIME_VALIDITY | CAPICOM_CHECK_SIGNATURE_VALIDITY | CAPICOM_CHECK_ONLINE_REVOCATION_STATUS ;			sig= SignedData.Signers.Item(1);		certStatus.VerificationTime=sig.AuthenticatedAttributes.Item(1).Value;		//alert(sig.AuthenticatedAttributes.Item(1).Value);		if (!certStatus.result){			var Chain = new ActiveXObject("CAPICOM.Chain");      		Chain.Build(cert);      		 for (var i=1;i<=Chain.Certificates.Count;i++){      		 	      		 	if (CAPICOM_TRUST_IS_NOT_SIGNATURE_VALID & Chain.Status(i))      			{			       alert("CryptoAPI found a problem with the signature on '" +  Certificate.GetInfo(CAPICOM_INFO_SUBJECT_SIMPLE_NAME) + "'");			       return false;			      }			      if ((CAPICOM_TRUST_IS_UNTRUSTED_ROOT & Chain.Status(i)) || (CAPICOM_TRUST_IS_PARTIAL_CHAIN & Chain.Status(i)))			      {			       alert("CryptoAPI was unable to chain '" +  Certificate.GetInfo(CAPICOM_INFO_SUBJECT_SIMPLE_NAME) + "' to a trusted authority");			       return false;			      }			      if (CAPICOM_TRUST_IS_CYCLIC & Chain.Status(i))			      {			       alert("CAPICOM_TRUST_IS_CYCLIC");			       return false;			      }			      if (CAPICOM_TRUST_CTL_IS_NOT_TIME_VALID & Chain.Status(i))			      {				       alert("CAPICOM_TRUST_CTL_IS_NOT_TIME_VALID");				       return false;			      }     			 if (CAPICOM_TRUST_CTL_IS_NOT_SIGNATURE_VALID & Chain.Status(i))			      {				       alert("CAPICOM_TRUST_CTL_IS_NOT_SIGNATURE_VALID");				       return false;			      }			      if (CAPICOM_TRUST_CTL_IS_NOT_VALID_FOR_USAGE & Chain.Status(i))			      {				       alert("CAPICOM_TRUST_CTL_IS_NOT_VALID_FOR_USAGE");				       return false;			      }			      if (CAPICOM_TRUST_IS_NOT_TIME_VALID & Chain.Status(i))			      {				       alert("CAPICOM_TRUST_IS_NOT_TIME_VALID");				       return false;			      }			      if (CAPICOM_TRUST_IS_NOT_TIME_NESTED & Chain.Status(i))			      {				       alert("CAPICOM_TRUST_IS_NOT_TIME_NESTED");				       return false;			      }			      if (CAPICOM_TRUST_IS_NOT_VALID_FOR_USAGE & Chain.Status(i))  				 {				       alert("CAPICOM_TRUST_IS_NOT_VALID_FOR_USAGE");				       return false;			      }			      if (CAPICOM_TRUST_IS_REVOKED & Chain.Status(i))			      {				       alert("CryptoAPI determined that '" +  Certificate.GetInfo(CAPICOM_INFO_SUBJECT_SIMPLE_NAME) + "' or one of its issuers was revoked.");				       return false;			      }			      if (CAPICOM_TRUST_REVOCATION_STATUS_UNKNOWN & Chain.Status(i))			      {      				 alert("CryptoAPI was unable to determine the certificate status for '" +  Certificate.GetInfo(CAPICOM_INFO_SUBJECT_SIMPLE_NAME) + "'");				       return false;			      }      		 	      		 	      		 }			alert("Certificado Revocado");			return "NULL";		}*/	}	catch (e){		//alert(e.description);		if (e.number=="-2146762486")			return "NOTRUST";		return "NULL";	}	return usuario;}function findCertificado(txtNombre){  	var MyStore = new ActiveXObject("CAPICOM.Store");	var FilteredCertificates = new ActiveXObject("CAPICOM.Certificates");	 // Se abre el store de certificados personales	try{		MyStore.Open(CAPICOM_CURRENT_USER_STORE, "My", CAPICOM_STORE_OPEN_READ_ONLY);	}	catch (e){		if (e.number != CAPICOM_E_CANCELLED){			alert("An error occurred while opening your personal certificate store, aborting");			return false;		}	}	var FilteredCertificates = MyStore.Certificates.Find(CAPICOM_CERTIFICATE_FIND_SUBJECT_NAME,txtNombre);	return FilteredCertificates;	}